library flhooks;

import 'package:flutter/widgets.dart';

/// [Hook] is the same as a property in the [State] of a [StatefulWidget].
/// [value], [store] and [dispose] will be saved in the current [State].
///
/// [Hook] can only be created and modified by an [HookTransformer] function,
/// consumed by the [use] function.
class Hook<V, S> {
  const Hook({
    this.value,
    this.store,
    this.dispose,
  });

  final V value;
  final S store;
  final Function dispose;
}

/// Define the type of an hook transformer function.
///
/// [HookTransformer] consume the current [Hook] in the context,
/// and return the new [Hook].
/// [HookTransformer] can only be consumed by the [use] function.
typedef HookTransformer<V, S> = Hook<V, S> Function(Hook<V, S>);

StateSetter _currentSetState;
List<Hook> _currentHooks;
int _currentIndex;

void Function(StateSetter, List<Hook>, int) _setHooksContext = (
  setState,
  hooks,
  index,
) {
  _currentSetState = setState;
  _currentHooks = hooks;
  _currentIndex = index;
};


/// Define the type of a builder function how can use Hooks.
typedef HookWidgetBuilder = Widget Function(BuildContext);

class _HookBuilderState extends State<HookBuilder> {
  _HookBuilderState({@required builder, dispose}):
  _builder = builder,
  _dispose = dispose;

  final StatefulWidgetBuilder _builder;
  final Function _dispose;

  @override
  Widget build(BuildContext context) {
    return this._builder(context, setState);
  }

  @override
  void dispose() {
    if (_dispose != null) {
      _dispose();
    }
    super.dispose();
  }
}

/// [HookBuilder] is like a [StatefulBuilder] how build the [builder] function.
/// Hooks function can be used only in the [builder] function.
///
/// ```dart
/// // Define a Slider Page
/// final SliderPage = () =>
///    HookBuilder(
///      builder: (BuildContext context) {
///        // define a state of type double
///        final example = useState(0.0);
///        final onChanged = useCallback((double newValue) {
///          // call example.set for update the value in state
///          example.set(newValue);
///        }, [example]);
///        return Material(
///          child: Center(
///            child: Slider(
///              key: sliderKey,
///              value: example.value,
///              onChanged: onChanged,
///            ),
///          ),
///        );
///      },
///    );
/// // Start the app
/// void main() =>
///     runApp(MaterialApp(
///       home: SliderPage(),
///     ));
/// ```
class HookBuilder extends StatefulWidget {
  HookBuilder({Key key, @required this.builder})
      : assert(builder != null),
        this.hooks = [],
        super(key: key);

  final HookWidgetBuilder builder;
  final List<Hook> hooks;

  @override
  State<StatefulWidget> createState() {
    return _HookBuilderState(
      builder: (context, setState) {
        _setHooksContext(setState, hooks, 0);
        final result = builder(context);
        _setHooksContext(null, null, null);
        return result;
      },
      dispose: () {
        hooks.forEach((hook) {
          if (hook.dispose != null) {
            hook.dispose();
          }
        });
      },
    );
  }
}

/// [use] consume the [transformer],
/// return the [Hook.value] of the [Hook] generated by the [transformer],
/// store the [Hook] in the current hooks context.
///
/// All Hooks function will start with use, and call [use] directly or indirectly.
/// [use] can only be used in the [HookBuilder.builder],
/// abort the execution if the hook context is not well formed.
///
/// ### Good
/// ```dart
///   final useAsync = () => use(AsyncTransformer(...));
/// ```
///
/// ### Bad
/// ```dart
///   final asyncHook = () => AsyncTransformer(...)();
/// ```
V use<V, S>(HookTransformer<V, S> transformer) {
  assert(_currentIndex != null,
  'the current index of the hook context cannot be null');
  assert(_currentHooks != null,
  'the current hooks of the hook context cannot be null');
  assert(_currentSetState != null,
  'the current setState of the hook contect cannot be null');
  if (_currentHooks.length <= _currentIndex) {
    _currentHooks.length = _currentIndex + 1;
  }
  final currentHook = _currentHooks[_currentIndex];
  final hook = transformer(currentHook);
  assert(hook != null, 'a transformer cannot return null value');
  _currentHooks[_currentIndex] = hook;
  _currentIndex += 1;
  return hook.value;
}

/// Return the memoized value of [fn].
///
/// [fn] will be recalled only if [store] change.
/// ```dart
/// final helloMessage = useMemo(() => 'Hello ${name}', [name]);
/// ```
V useMemo<V>(V Function() fn, List store) {
  return use<V, List>((current) {
    if (current != null) {
      final oldStore = current.store;
      if (store.every((e) => oldStore.any((o) => o == e))) {
        return current;
      }
    }
    return Hook(
      value: fn(),
      store: store,
    );
  });
}

/// Exec [fn] at first call or if [store] change.
/// If [fn] return a function, this will be called if [store] change
/// or when the widget dispose.
///
/// ```dart
/// final helloMessage = useEffect(() {
///   final pub = stream.listen(callback);
///   return () => pub.cancel();
/// }, [stream]);
/// ```
///
/// [useEffect] is useful for async or stream subscription.
void useEffect(Function Function() fn, List store) {
  use<void, List>((current) {
    if (current != null) {
      final oldStore = current.store;
      if (store.every((e) => oldStore.any((o) => o == e))) {
        return current;
      }
      if (current.dispose != null) {
        current.dispose();
      }
    }
    return Hook(
      value: null,
      store: store,
      dispose: fn(),
    );
  });
}

/// Return the first reference to [fn].
///
/// [fn] reference will change only if [store] change.
/// ```dart
/// final onClick = useCallback(() => ..., [input1, input2]);
/// ```
/// It's the same as passing `() => fn` to [useMemo].
final Function Function(Function fn, List store) useCallback =
    (Function fn, List store) => useMemo(() => fn, store);

/// Is an hook state value and setter.
class HookState<V> {
  HookState({
    @required this.value,
    this.set,
  });

  V value;
  void Function(V) set;
}

/// Return an [HookState],
/// [HookState.value] is [initial] or the last passed to [HookState.set].
/// Will trigger the rebuild of the [StatefulBuilder].
///
/// ```dart
/// final name = useState('');
/// // ... get the value
/// Text(name.value);
/// //... update the value
/// onChange: (newValue) => name.set(newValue);
/// ```
HookState<V> useState<V>(V initial) {
  final setState = _currentSetState;
  return useMemo(() {
    final state = HookState<V>(
      value: initial,
    );
    state.set = (value) => setState(() => state.value = value);
    return state;
  }, []);
}

